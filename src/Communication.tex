\chapter{Communication}
In this chapter we are going to explore the concept of communication starting from the easiest form of communication possible in the world of computer science: Client-Server. When working with a client-server architecture we will always be facing two different entities: server and client.

The client side is usually regarded as the lighter one (usually only contains frontend code) but client software may include more than just UI, it might implement logic to achieve different transparency requirements (like Access, Location, Migration, etc...).

The server side is the one implementing the actual service logic, it can be implemented in a concurrent or iterative way depending on the type of service and the amount of traffic generated by it. Servers can also be stateful or stateless, a stateless server does not keep accurate information about the status of a client; a stateful server, on the other hand, keeps track of the status of its clients and has a bunch of different ways to track client's activities:
\begin{itemize}
    \item Record that a file has been opened.
    \item Record what data has been cached.
    \item Use the cookies on the client to keep track of more complex and structured information.
\end{itemize}
It's important to keep in mind that distribution is not just data passing, but also process passing or sharing in a load distribution environment. When working on clusters usually processes are moved around inside the cluster to make sure that the servers in the data center are sufficiently loaded, the load is actually balanced between the various machines and the computation actually happens as close to the data as possible.

Now, before carrying on we will go through a very fast revision of the communication stack and protocols that characterise the world of inter-machine communication.

The communication stack is the one that we already know (Stack ISO/OSI with 7 layers), to this we add a layer which we call Middleware layer, and is basically just an intermediate virtual layer that provides common services and protocols that can be used by many different applications, just to name a few we have:
\begin{itemize}
    \item A rich set of communication protocols.
    \item Marshalling and unmarshalling of data.
    \item Naming protocols.
    \item Security protocols.
    \item Scaling mechanisms such as replication and caching.
\end{itemize}
Usually it's not really easy to establish where functionalities belong in the stack, especially when we move higher up in the stack itself, an example is the DNS functionality, which is considered application level according to the ISO/OSI stack but it is actually application-independent and should be a middleware service.

Communication between two agents can have different characteristics, it can be:
\begin{itemize}
    \item Synchronous or Asynchronous.
    \item Transient or Persistent.
\end{itemize}
If we consider the various architectural models that we have introduced a couple of chapters ago we can think of the Client-server paradigm as a synchronous and transient communication scheme, while a message-oriented middleware aims at high-level persistent asynchronous communication.

We also previously briefly mentioned the RPC framework to allow remote procedure calls from other processes or even different machines, the framework simply mimics a local procedure call while calling a remote object. To do this stubs are required as anchors between the two agents and the procedures operate in isolation, they can even be carried out asynchronously (with all the advantages and disadvantages that this brings with it).

Nowadays RPC is mounted in most languages and there are tools that simplify its development like the GRPC framework. In 1990s a development environment was created called Distributed Computing Environment. This environment came with:
\begin{itemize}
    \item A remote procedure call mechanism (DCE/RPC).
    \item A naming (directory) service.
    \item A time service.
    \item An authentication service.
    \item A distributed file system known as DCE/DFS.
\end{itemize}
this environment implemented the client-server model and used DCE/RPC to bind server and clients, hide communication and access remote services via local call. The client-to-server binding is explained in Figure \ref{fig:client_server_binding}.
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{img/Client_server_binding_DCE.png}
    \caption{Client to server binding}
    \label{fig:client_server_binding}
\end{figure}
Another very simple example of transient messaging is the socket system, we are not going to go through it again and we will give for granted that it's known. An upgrade for that is ZeroMQ, a library that acts like a concurrency framework and gives the developer the ability to use sockets that carry atomic messages across various transports like in-process, inter-process, TCP, and multicast; it's possible to connect sockets N-to-N with patterns like fan-out, publish-subscribe, task distribution, and request-reply. All the communication is carried out asynchronously.

Asynchronous communication can be made persistent through support of middleware-level queues and queue managers that act like brokers.

Multicast communication can be achieved in more than one way:
\begin{itemize}
    \item Application level tree-based multicasting, in which we use an overlay network to disseminate data.
    \item Flooding-based multicasting.
    \item Goddip-based data dissemination (epidemic behaviour).
\end{itemize}
